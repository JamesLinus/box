{
    "docs": [
        {
            "location": "/", 
            "text": "Box is a small utility for the building of docker images. Through use of mruby,\nwe provide additional flexibility over the vanilla \ndocker build\n command by\nadding control structures and basic predicates. We also add new verbs that\nallow new actions, such as flattening and tagging images.\n\n\nSome features that differentiate it from \ndocker build\n:\n\n\n\n\nUnique general features:\n\n\nmruby syntax\n\n\nfiltering of keywords to secure builds\n\n\n\n\n\n\nIn the build plan itself:\n\n\nTagging\n\n\nFlattening\n\n\nDebug mode (drop to a shell in the middle of a plan run and inspect your container)\n\n\nRuby block methods for \nuser\n (\nwith_user\n) and \nworkdir\n (\ninside\n) allow\n  you to scope \ncopy\n and \nrun\n operations for a more obvious build plan.\n\n\n\n\n\n\n\n\nGetting Box\n\n\nDownload Release v0.2.1\n\n\nInvocation\n\n\nThe commandline tool \nbox\n accepts a file (your \"build plan\") as a commandline\nargument:\n\n\n$ box myplan.rb\n\n\n\n\nThe current working directory that Box runs in is very important, it is the\njumping-off point for most copy operations. If you run the \nerikh/box\n\ncontainer, you may wish to run it in this way:\n\n\n$ docker run -i \\\n  -v $PWD:$PWD \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -w $PWD \\\n  erikh/box:latest myplan.rb\n\n\n\n\nFor additional flags and functionality, see the help:\n\n\n$ box --help\n\n\n\n\nMaking Box Scripts\n\n\nBox scripts are written in mruby, an embedded, smaller variant of ruby. If you\nare new to ruby, here is a tutorial that only \ncovers the basics\n.\nYou will not need to be an advanced ruby user to leverage Box.\n\n\nBox script terms are either functions or verbs.\n\n\nVerbs typically create a layer and are meant to run at the top level of the\nscript; they are not intended to return a sane value other than success/fail.\nOperations like \nrun\n and \ncopy\n fit into the \"verb\" category. These are very\nsimilar to the verbs you'd find in \ndocker build\n.\n\n\nFunctions are unique to Box and allow you to pass data both from the image into\nthe build system and pass it to other calls, or just print it out for later\nuse. Functions like \ngetuid\n exist to retrieve the UID of a user as the\ncontainer sees it, for the purposes of using it for future operations.\n\n\nPlease take a look at our \nverbs reference\n and \nfunctions\nreference\n for more information.\n\n\nExample Box Script\n\n\nHere's a basic example that downloads the newest (1.7.3) version of golang with\ncurl and unpacks it. If you set an environment variable called\n\nGO_VERSION\n, it will use that version instead.\n\n\nfrom \ndebian\n\n\nrun \napt-get update\n\nrun \napt-get install curl -y\n\n\ngo_version = getenv(\nGO_VERSION\n)\n\nif go_version.empty?\n  go_version = \n1.7.3\n\nend\n\nurl = \nhttps://storage.googleapis.com/golang/go#{go_version}.linux-amd64.tar.gz\n\n\nrun \ncurl -sSL '#{url}' | tar -xvz -C /usr/local\n\n\n\n\n\nThe Build Cache\n\n\nThe build cache is enabled by default. It is not an exact cache but constructs\nthe layer graph in a non-standard way using docker's image Comment field,\npopulating it with sums and command instructions in a very similar way that\n\ndocker build\n does.\n\n\nIf you find the behavior surprising, you can turn it off:\n\n\n$ box --no-cache myplan.rb\n\n\n\n\nExample Box Script (advanced version)\n\n\nThis is the Box script we use to build Box itself. It uses many of its\nfeatures. Be sure to check the \nverbs\n to\nrefer to different constructs used in the file.\n\n\nYou can find the latest version of it\n\nhere\n too.\n\n\nfrom \ngolang\n\n\npackages = %w[\n  build-essential\n  g++\n  git\n  wget\n  curl\n  ruby\n  bison\n  flex\n  iptables\n  psmisc\n]\n\nrun \napt-get update\n\nrun \napt-get install -y #{packages.join(\n \n)}\n\nenv \nGOPATH\n =\n \n/go\n\n\nif getenv(\nRELEASE\n) == \n\n  run \nwget https://get.docker.com/builds/Linux/x86_64/docker-1.12.1.tgz\n\n  run \ntar -xpf docker-1.12.1.tgz --strip-components=1 -C /usr/bin/\n\n  run \nrm docker-1.12.1.tgz\n\n  copy \ndind\n, \n/dind\n\nend\n\ncopy \n.\n, \n/go/src/github.com/erikh/box\n\n\nif getenv(\nIGNORE_LIBMRUBY\n) == \n\n  run \ncd /go/src/github.com/erikh/box \n make\n\nend\n\nif getenv(\nRELEASE\n) != \n\n  run \nmv /go/bin/box /box\n\n  set_exec entrypoint: [\n/box\n], cmd: []\n  run \napt-get purge -y #{packages.join(\n \n)}\n\n  run \napt-get autoclean\n\n  run \nrm -rf /usr/local /go /var/cache/apt /var/lib/apt\n\n  flatten\n  tag \nerikh/box:latest\n\nelse\n  workdir \n/go/src/github.com/erikh/box\n\n  set_exec entrypoint: [\n/dind\n], cmd: [\nmake\n, \ndocker-test\n]\n  tag \nbox-test\n\nend\n\n\n\n\nCaveats\n\n\nYou can see \nall of our issues\n here.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#getting-box", 
            "text": "Download Release v0.2.1", 
            "title": "Getting Box"
        }, 
        {
            "location": "/#invocation", 
            "text": "The commandline tool  box  accepts a file (your \"build plan\") as a commandline\nargument:  $ box myplan.rb  The current working directory that Box runs in is very important, it is the\njumping-off point for most copy operations. If you run the  erikh/box \ncontainer, you may wish to run it in this way:  $ docker run -i \\\n  -v $PWD:$PWD \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -w $PWD \\\n  erikh/box:latest myplan.rb  For additional flags and functionality, see the help:  $ box --help", 
            "title": "Invocation"
        }, 
        {
            "location": "/#making-box-scripts", 
            "text": "Box scripts are written in mruby, an embedded, smaller variant of ruby. If you\nare new to ruby, here is a tutorial that only  covers the basics .\nYou will not need to be an advanced ruby user to leverage Box.  Box script terms are either functions or verbs.  Verbs typically create a layer and are meant to run at the top level of the\nscript; they are not intended to return a sane value other than success/fail.\nOperations like  run  and  copy  fit into the \"verb\" category. These are very\nsimilar to the verbs you'd find in  docker build .  Functions are unique to Box and allow you to pass data both from the image into\nthe build system and pass it to other calls, or just print it out for later\nuse. Functions like  getuid  exist to retrieve the UID of a user as the\ncontainer sees it, for the purposes of using it for future operations.  Please take a look at our  verbs reference  and  functions\nreference  for more information.", 
            "title": "Making Box Scripts"
        }, 
        {
            "location": "/#example-box-script", 
            "text": "Here's a basic example that downloads the newest (1.7.3) version of golang with\ncurl and unpacks it. If you set an environment variable called GO_VERSION , it will use that version instead.  from  debian \n\nrun  apt-get update \nrun  apt-get install curl -y \n\ngo_version = getenv( GO_VERSION )\n\nif go_version.empty?\n  go_version =  1.7.3 \nend\n\nurl =  https://storage.googleapis.com/golang/go#{go_version}.linux-amd64.tar.gz \n\nrun  curl -sSL '#{url}' | tar -xvz -C /usr/local", 
            "title": "Example Box Script"
        }, 
        {
            "location": "/#the-build-cache", 
            "text": "The build cache is enabled by default. It is not an exact cache but constructs\nthe layer graph in a non-standard way using docker's image Comment field,\npopulating it with sums and command instructions in a very similar way that docker build  does.  If you find the behavior surprising, you can turn it off:  $ box --no-cache myplan.rb", 
            "title": "The Build Cache"
        }, 
        {
            "location": "/#example-box-script-advanced-version", 
            "text": "This is the Box script we use to build Box itself. It uses many of its\nfeatures. Be sure to check the  verbs  to\nrefer to different constructs used in the file.  You can find the latest version of it here  too.  from  golang \n\npackages = %w[\n  build-essential\n  g++\n  git\n  wget\n  curl\n  ruby\n  bison\n  flex\n  iptables\n  psmisc\n]\n\nrun  apt-get update \nrun  apt-get install -y #{packages.join(   )} \nenv  GOPATH  =   /go \n\nif getenv( RELEASE ) ==  \n  run  wget https://get.docker.com/builds/Linux/x86_64/docker-1.12.1.tgz \n  run  tar -xpf docker-1.12.1.tgz --strip-components=1 -C /usr/bin/ \n  run  rm docker-1.12.1.tgz \n  copy  dind ,  /dind \nend\n\ncopy  . ,  /go/src/github.com/erikh/box \n\nif getenv( IGNORE_LIBMRUBY ) ==  \n  run  cd /go/src/github.com/erikh/box   make \nend\n\nif getenv( RELEASE ) !=  \n  run  mv /go/bin/box /box \n  set_exec entrypoint: [ /box ], cmd: []\n  run  apt-get purge -y #{packages.join(   )} \n  run  apt-get autoclean \n  run  rm -rf /usr/local /go /var/cache/apt /var/lib/apt \n  flatten\n  tag  erikh/box:latest \nelse\n  workdir  /go/src/github.com/erikh/box \n  set_exec entrypoint: [ /dind ], cmd: [ make ,  docker-test ]\n  tag  box-test \nend", 
            "title": "Example Box Script (advanced version)"
        }, 
        {
            "location": "/#caveats", 
            "text": "You can see  all of our issues  here.", 
            "title": "Caveats"
        }, 
        {
            "location": "/cli/", 
            "text": "Command-Line Options in box alter behavior of box for its runtime.  Using these\noptions shape your build and suit it for use in many group environments.\n\n\nIn the documentation below, each long option is in the heading with the short\noption (if any) in parentheses.\n\n\n--help (-h) and --version (-v)\n\n\nShow the help and version respectively.\n\n\n--no-cache (-n)\n\n\nTurn caching off, this forces a rebuild of all build plan steps. Note that\nthis won't re-pull any pulled images.\n\n\nExample:\n\n\n$ box -n plan.rb\n\n\n\n\n--omit (-o)\n\n\nOmit a function or verb from the DSL. This removes all functionality of a\nspecific mruby verb or function and causes a syntax error if encountered.  This\nrestricts certain operations in builds for teams or unprivileged scenarios.\n\n\nExample:\n\n\n$ cat \nplan.rb \nEOF\nfrom 'debian'\ntag 'mydebian'\nEOF\n# boom - missing keyword or function from ruby\n$ box -o tag plan.rb\n\n\n\n\n--tag (-t)\n\n\nTag the last generated image with the provided value. If the tag fails, the\nbuild won't fail, but instead be untagged. However, box still exits\nnon-zero to indicate the tag failed.\n\n\nExample:\n\n\n# starts a build with debian and retags the result as 'mydebian'\necho \nfrom 'debian'\n | box -t mydebian\n\n\n\n\n--no-tty\n\n\nForcibly turn all tty operation/propagation off for this run. This will cause\nmany programs to behave different specifically in \nrun\n statements, and the\n\npull\n animations for downloading will not be provided.\n\n\nNo TTY mode is the default when unix pipes are involved.\n\n\n--force-tty\n\n\nForce the TTY on even if it is off for some reason.\n\n\nThe combination of \n--no-tty --force-tty\n is to force the tty.", 
            "title": "Command-Line Options"
        }, 
        {
            "location": "/cli/#-help-h-and-version-v", 
            "text": "Show the help and version respectively.", 
            "title": "--help (-h) and --version (-v)"
        }, 
        {
            "location": "/cli/#-no-cache-n", 
            "text": "Turn caching off, this forces a rebuild of all build plan steps. Note that\nthis won't re-pull any pulled images.  Example:  $ box -n plan.rb", 
            "title": "--no-cache (-n)"
        }, 
        {
            "location": "/cli/#-omit-o", 
            "text": "Omit a function or verb from the DSL. This removes all functionality of a\nspecific mruby verb or function and causes a syntax error if encountered.  This\nrestricts certain operations in builds for teams or unprivileged scenarios.  Example:  $ cat  plan.rb  EOF\nfrom 'debian'\ntag 'mydebian'\nEOF\n# boom - missing keyword or function from ruby\n$ box -o tag plan.rb", 
            "title": "--omit (-o)"
        }, 
        {
            "location": "/cli/#-tag-t", 
            "text": "Tag the last generated image with the provided value. If the tag fails, the\nbuild won't fail, but instead be untagged. However, box still exits\nnon-zero to indicate the tag failed.  Example:  # starts a build with debian and retags the result as 'mydebian'\necho  from 'debian'  | box -t mydebian", 
            "title": "--tag (-t)"
        }, 
        {
            "location": "/cli/#-no-tty", 
            "text": "Forcibly turn all tty operation/propagation off for this run. This will cause\nmany programs to behave different specifically in  run  statements, and the pull  animations for downloading will not be provided.  No TTY mode is the default when unix pipes are involved.", 
            "title": "--no-tty"
        }, 
        {
            "location": "/cli/#-force-tty", 
            "text": "Force the TTY on even if it is off for some reason.  The combination of  --no-tty --force-tty  is to force the tty.", 
            "title": "--force-tty"
        }, 
        {
            "location": "/verbs/", 
            "text": "Verbs take action on a container and usually create a layer. Some commands can\nbe used to move data into and out of containers, or set properties and run\ncommands.\n\n\ndebug\n\n\ndebug\n drops to a container's shell (bash by default, but an argument can be\nprovided to change this) at the current place in the build cycle when invoked.\nChanges to the container will be persisted through the rest of the run, and a\nlayer will be created.\n\n\nIf the shell exits non-zero, like \nrun\n it will abort the build.\n\n\nThere is currently no way to detach from a debug session. Close the shell\nand/or programs.\n\n\nExample:\n\n\nfrom \ndebian\n\ncopy \n.\n, \n/test\n\ndebug # verify all files landed in test like you expected them to\nrun \nchown -R erikh:erikh /test\n # this will run after you close the shell\n\n\n\n\nset_exec\n\n\nset_exec\n sets both the entrypoint and cmd at the same time, allowing for no\nrace between the operations.\n\n\nset_exec\n takes a dictionary consisting of two known elements as symbols:\nentrypoint and cmd. They each take a string array which is then propagated\nto the respective properties in the container's configuration.\n\n\nThis command does not modify the entrypoint or cmd for \nrun\n operations.\n\n\nExample:\n\n\nfrom \ndebian\n\n# this sets the what will be run with `/bin/echo foo`\nset_exec entrypoint: [\n/bin/echo\n], cmd: [\nfoo\n]\n\n\n\n\nworkdir\n\n\nworkdir sets the working directory in the docker environment. It sets this\nthroughout the image creation; all run/copy statements will respect this\nvalue. If you wish to break out or work within it further, look at the\n\ninside\n call.\n\n\nThe workdir, if left empty by either the parent in \nfrom\n or from no\ninteraction from the plan, is set to \n/\n to avoid inheriting accidentally from\nthe parent image.\n\n\nExample:\n\n\nfrom \ndebian\n\n# each container that runs this image without the `-w` flag will start as\n# `/test` for the current working directory.\nworkdir '/test'\n\n\n\n\nuser\n\n\nuser sets the username this container will use by default. It also affects\nfollowing run statements (but not copy, which always copies as root\ncurrently). If you wish to switch to a user temporarily, consider using\n\nwith_user\n.\n\n\nAn empty user is always set to \nroot\n in the final image.\n\n\nExample:\n\n\nfrom \ndebian\n\n# all containers started with this image will use user `foo`\n# %q[] just means, \nquote this as a string without interpolation\n\nuser %q[foo]\n\n\n\n\nflatten\n\n\nflatten requires no argumemnts and flattens all layers and commits a new\nlayer. This is useful for reducing the size of images or making them easier\nto distribute.\n\n\nNOTE: flattening will always bust the build cache.\n\n\nNOTE: flattening requires downloading the image and re-uploading it. This\ncan take a lot of time over remote connections and is not advised.\n\n\nExample:\n\n\nfrom \ndebian\n\n# create some layers\nrun \ntrue\n\ncopy \n.\n, \n/test\n\nflatten # image is shrunk to one layer here\ntag \nerikh/test\n\n\n\n\n\ntag\n\n\ntag tags an image within the docker daemon, named after the string provided.\nIt must be a valid tag name.\n\n\nExample:\n\n\nfrom \ndebian\n\nrun \ntrue\n # create a layer\ntag \nerikh/true\n # tag the latest image as \nerikh/true\n\n\n\n\n\nentrypoint\n\n\nentrypoint sets the entrypoint for the image at runtime. It will not be\nused for run invocations. Note that setting this clears any previously set cmd.\n\n\nExample:\n\n\nfrom \ndebian\n\nentrypoint \n/bin/echo\n # all `docker run` commands will be preceded by this\ncmd \nfoo\n              # this will equate to `/bin/echo foo`\n\n\n\n\nfrom\n\n\nfrom sets the initial image and if necessary, pulls it from the registry. It\nalso sets the initial layer and must be called before several operations.\n\n\nUsing \nfrom\n overwrites all container configuration, including \nworkdir\n,\n\nuser\n, \nenv\n, \ncmd\n, and \nentrypoint\n.\n\n\nIt is generally expected that \nfrom\n is called first in a build plan.\n\n\nExample:\n\n\nfrom \ndebian\n\n\n\n\n\nor other images with full tags:\n\n\nfrom \nceph/rbd:latest\n\n\n\n\n\nor fully qualified image IDs.\n\n\n# sha256s are longer than this normally.\nfrom \nsha256:deadbeefcafebabeaddedbeef\n\n\n\n\n\nrun\n\n\nrun runs a command provided as a string, and saves the layer.\n\n\nIt respects user and workdir, but not entrypoint and command. It does this\nso it can respect the values provided in the script instead of what was\nintended for the final image.\n\n\nCache keys are generated based on the command name, so to be certain your\ncommand is run in the event of it hitting cache, run box with NO_CACHE=1.\n\n\nExamples:\n\n\nCreate a file called \n/bar\n inside the container, then chown it to nobody. Run\ncommands don't need a lot of \n because you can trivially flatten the layers.\n\n\nRun does not accept the exec-form from docker's RUN equivalent. Everything RUN\nprocesses goes through \n/bin/sh -c\n.\n\n\nfrom \ndebian\n\nrun \necho foo \n/bar\n\nrun \nchown nobody:nogroup /bar\n\n\n\n\n\nRun in the context of a specific user or workdir. This allows us to finely\ncontrol our run invocations and further processing after the container image\nhas been run.\n\n\nfrom \ndebian\n\n\nwith_user \nnobody\n do # just the commands inside this block will run as `nobody`\n  run \necho foo \n/tmp/bar\n\nend\n\n# notice how we are still root\nrun \nuseradd -s /bin/sh -m -d /home/erikh erikh\n\n\n# all commands from here on will run as `erikh`, overriden only by `with_user`\n# and other `user` calls.\nuser \nerikh\n\nrun \necho foo \n/tmp/erikh-file\n\n\n# set the workdir temporarily for the commands within the block.\n# this will create /tmp/another-file-in-tmp.\ninside \n/tmp\n do\n  run \necho foo \nanother-file-in-tmp\n\nend\n\n# this behaves exactly like user, just setting the default cwd instead:\n# creates /tmp/yet-another-file\nworkdir \n/tmp\n\nrun \necho foo \nyet-another-file\n\n\n\n\n\nwith_user\n\n\nwith_user\n, when provided with a string username and block invokes commands\nwithin the user's login context. Unfortunately, copy does not respect this\nyet. It does not affect the final image.\n\n\nExample:\n\n\nfrom \ndebian\n\n\nwith_user \nnobody\n do\n  run \nwhoami\n # i am nobody!\nend\n\n\n\n\ninside\n\n\ninside, when provided with a directory name string and block, invokes\ncommands within the context of the working directory being set to the\nstring. It does not affect the final image.\n\n\nExample:\n\n\nfrom \ndebian\n\n\ninside \n/dev\n do\n  run \nmknod webscale c 1 3\n\nend\n\n\n\n\nenv\n\n\nenv, when provided with a hash of string =\n string key/value combinations,\nwill set the environment in the image and future run invocations.\n\n\nExample:\n\n\nfrom \ndebian\n\n\nenv \nGOPATH\n =\n \n/go\n, \nPATH\n =\n \n/usr/bin:/bin\n\nenv GOPATH: \n/go\n, PATH: \n/usr/bin:/bin\n # equivalent if you prefer this syntax\n\n\n\n\ncmd\n\n\ncmd, when provided with a string will set the docker image's Cmd property,\nwhich are the arguments that follow the entrypoint (and are overridden when\nyou provide a command to \ndocker run\n). It does not affect run invocations.\n\n\nNote that if you set this before entrypoint, it will be cleared.\n\n\nExample:\n\n\nfrom \ndebian\n\n# entrypoint is `/bin/sh -c` by default, so we will just run whatever command\n# is thrown at us. This image will run `ls` in the workdir by default.\ncmd \nls\n\n\n\n\n\ncopy\n\n\ncopy copies files from the host to the container. It only works relative to\nthe current directory. The build cache is calculated by summing the tar\nresult of edited files. Since mtime is also considered, changes to that will\nalso bust the cache.\n\n\nNOTE: copy does not respect user permissions when the \nuser\n or \nwith_user\n\nmodifiers are applied. This will be fixed eventually.\n\n\nExample:\n\n\nfrom \ndebian\n\n\n# recursively copies everything the cwd to test, which is relative to the\n# workdir inside the container (`/` by default).\ncopy \n.\n, \n/test", 
            "title": "Verb Reference"
        }, 
        {
            "location": "/verbs/#debug", 
            "text": "debug  drops to a container's shell (bash by default, but an argument can be\nprovided to change this) at the current place in the build cycle when invoked.\nChanges to the container will be persisted through the rest of the run, and a\nlayer will be created.  If the shell exits non-zero, like  run  it will abort the build.  There is currently no way to detach from a debug session. Close the shell\nand/or programs.  Example:  from  debian \ncopy  . ,  /test \ndebug # verify all files landed in test like you expected them to\nrun  chown -R erikh:erikh /test  # this will run after you close the shell", 
            "title": "debug"
        }, 
        {
            "location": "/verbs/#set95exec", 
            "text": "set_exec  sets both the entrypoint and cmd at the same time, allowing for no\nrace between the operations.  set_exec  takes a dictionary consisting of two known elements as symbols:\nentrypoint and cmd. They each take a string array which is then propagated\nto the respective properties in the container's configuration.  This command does not modify the entrypoint or cmd for  run  operations.  Example:  from  debian \n# this sets the what will be run with `/bin/echo foo`\nset_exec entrypoint: [ /bin/echo ], cmd: [ foo ]", 
            "title": "set_exec"
        }, 
        {
            "location": "/verbs/#workdir", 
            "text": "workdir sets the working directory in the docker environment. It sets this\nthroughout the image creation; all run/copy statements will respect this\nvalue. If you wish to break out or work within it further, look at the inside  call.  The workdir, if left empty by either the parent in  from  or from no\ninteraction from the plan, is set to  /  to avoid inheriting accidentally from\nthe parent image.  Example:  from  debian \n# each container that runs this image without the `-w` flag will start as\n# `/test` for the current working directory.\nworkdir '/test'", 
            "title": "workdir"
        }, 
        {
            "location": "/verbs/#user", 
            "text": "user sets the username this container will use by default. It also affects\nfollowing run statements (but not copy, which always copies as root\ncurrently). If you wish to switch to a user temporarily, consider using with_user .  An empty user is always set to  root  in the final image.  Example:  from  debian \n# all containers started with this image will use user `foo`\n# %q[] just means,  quote this as a string without interpolation \nuser %q[foo]", 
            "title": "user"
        }, 
        {
            "location": "/verbs/#flatten", 
            "text": "flatten requires no argumemnts and flattens all layers and commits a new\nlayer. This is useful for reducing the size of images or making them easier\nto distribute.  NOTE: flattening will always bust the build cache.  NOTE: flattening requires downloading the image and re-uploading it. This\ncan take a lot of time over remote connections and is not advised.  Example:  from  debian \n# create some layers\nrun  true \ncopy  . ,  /test \nflatten # image is shrunk to one layer here\ntag  erikh/test", 
            "title": "flatten"
        }, 
        {
            "location": "/verbs/#tag", 
            "text": "tag tags an image within the docker daemon, named after the string provided.\nIt must be a valid tag name.  Example:  from  debian \nrun  true  # create a layer\ntag  erikh/true  # tag the latest image as  erikh/true", 
            "title": "tag"
        }, 
        {
            "location": "/verbs/#entrypoint", 
            "text": "entrypoint sets the entrypoint for the image at runtime. It will not be\nused for run invocations. Note that setting this clears any previously set cmd.  Example:  from  debian \nentrypoint  /bin/echo  # all `docker run` commands will be preceded by this\ncmd  foo               # this will equate to `/bin/echo foo`", 
            "title": "entrypoint"
        }, 
        {
            "location": "/verbs/#from", 
            "text": "from sets the initial image and if necessary, pulls it from the registry. It\nalso sets the initial layer and must be called before several operations.  Using  from  overwrites all container configuration, including  workdir , user ,  env ,  cmd , and  entrypoint .  It is generally expected that  from  is called first in a build plan.  Example:  from  debian   or other images with full tags:  from  ceph/rbd:latest   or fully qualified image IDs.  # sha256s are longer than this normally.\nfrom  sha256:deadbeefcafebabeaddedbeef", 
            "title": "from"
        }, 
        {
            "location": "/verbs/#run", 
            "text": "run runs a command provided as a string, and saves the layer.  It respects user and workdir, but not entrypoint and command. It does this\nso it can respect the values provided in the script instead of what was\nintended for the final image.  Cache keys are generated based on the command name, so to be certain your\ncommand is run in the event of it hitting cache, run box with NO_CACHE=1.  Examples:  Create a file called  /bar  inside the container, then chown it to nobody. Run\ncommands don't need a lot of   because you can trivially flatten the layers.  Run does not accept the exec-form from docker's RUN equivalent. Everything RUN\nprocesses goes through  /bin/sh -c .  from  debian \nrun  echo foo  /bar \nrun  chown nobody:nogroup /bar   Run in the context of a specific user or workdir. This allows us to finely\ncontrol our run invocations and further processing after the container image\nhas been run.  from  debian \n\nwith_user  nobody  do # just the commands inside this block will run as `nobody`\n  run  echo foo  /tmp/bar \nend\n\n# notice how we are still root\nrun  useradd -s /bin/sh -m -d /home/erikh erikh \n\n# all commands from here on will run as `erikh`, overriden only by `with_user`\n# and other `user` calls.\nuser  erikh \nrun  echo foo  /tmp/erikh-file \n\n# set the workdir temporarily for the commands within the block.\n# this will create /tmp/another-file-in-tmp.\ninside  /tmp  do\n  run  echo foo  another-file-in-tmp \nend\n\n# this behaves exactly like user, just setting the default cwd instead:\n# creates /tmp/yet-another-file\nworkdir  /tmp \nrun  echo foo  yet-another-file", 
            "title": "run"
        }, 
        {
            "location": "/verbs/#with95user", 
            "text": "with_user , when provided with a string username and block invokes commands\nwithin the user's login context. Unfortunately, copy does not respect this\nyet. It does not affect the final image.  Example:  from  debian \n\nwith_user  nobody  do\n  run  whoami  # i am nobody!\nend", 
            "title": "with_user"
        }, 
        {
            "location": "/verbs/#inside", 
            "text": "inside, when provided with a directory name string and block, invokes\ncommands within the context of the working directory being set to the\nstring. It does not affect the final image.  Example:  from  debian \n\ninside  /dev  do\n  run  mknod webscale c 1 3 \nend", 
            "title": "inside"
        }, 
        {
            "location": "/verbs/#env", 
            "text": "env, when provided with a hash of string =  string key/value combinations,\nwill set the environment in the image and future run invocations.  Example:  from  debian \n\nenv  GOPATH  =   /go ,  PATH  =   /usr/bin:/bin \nenv GOPATH:  /go , PATH:  /usr/bin:/bin  # equivalent if you prefer this syntax", 
            "title": "env"
        }, 
        {
            "location": "/verbs/#cmd", 
            "text": "cmd, when provided with a string will set the docker image's Cmd property,\nwhich are the arguments that follow the entrypoint (and are overridden when\nyou provide a command to  docker run ). It does not affect run invocations.  Note that if you set this before entrypoint, it will be cleared.  Example:  from  debian \n# entrypoint is `/bin/sh -c` by default, so we will just run whatever command\n# is thrown at us. This image will run `ls` in the workdir by default.\ncmd  ls", 
            "title": "cmd"
        }, 
        {
            "location": "/verbs/#copy", 
            "text": "copy copies files from the host to the container. It only works relative to\nthe current directory. The build cache is calculated by summing the tar\nresult of edited files. Since mtime is also considered, changes to that will\nalso bust the cache.  NOTE: copy does not respect user permissions when the  user  or  with_user \nmodifiers are applied. This will be fixed eventually.  Example:  from  debian \n\n# recursively copies everything the cwd to test, which is relative to the\n# workdir inside the container (`/` by default).\ncopy  . ,  /test", 
            "title": "copy"
        }, 
        {
            "location": "/functions/", 
            "text": "Functions in Box provide a data-passing mechanism for build instructions. For\nexample, you may wish to read the contents of a file from the container into\nyour build for further processing; the \nread\n function allows that.\n\n\nThese are the functions supported by Box.\n\n\nimport\n\n\nimport loads a ruby file, and then executes it as if it were a box plan. This\nis prinicipally used to modularize build instructions between multiple builds.\n\n\nNote that this will load ruby files specified anywhere on the filesystem. Use\nat your own risk. You can provide the \n-o import\n option to omit this function\nfrom use.\n\n\nExample:\n\n\nFile A:\n\n\nfrom \ndebian\n\n\n\n\n\nFile B imports File A and builds on it:\n\n\nimport \nfile-a.rb\n\nrun \nls\n\n\n\n\n\ngetenv\n\n\ngetenv retrieves a value from the building environment (passed in as string)\nand returns a string with the value. If no value exists, an empty string is\nreturned.\n\n\nExample:\n\n\n# If you set IMAGE=ceph/rbd:latest in your environment, that would be pulled\n# via the `from` statement.\nfrom getenv(\nIMAGE\n)\n\n\n\n\nread\n\n\nread takes a filename as string, reads it from the latest image in the\nevaluation and returns its data. Yields an error if the file does not exist\nor from has not been called.\n\n\nread returns a string which may then be manipulated with normal string\nmanipulations in ruby.\n\n\nExample:\n\n\nfrom \ndebian\n\n# this gets the first username in your passwd file inside the debian image\nrun \necho #{read(\n/etc/passwd\n).split(\n\\n\n).first.split(\n:\n)[0]}\n\n\n\n\n\ngetuid\n\n\ngetuid, given a string username provides an integer response with the UID of\nthe user. This works by reading the /etc/passwd file in the image.\n\n\nYields an error if it cannot find the user or from has not been called.\n\n\nExample:\n\n\nfrom \ndebian\n\nrun \nuseradd -m -d /home/erikh -s /bin/sh erikh\n\nrun \nid #{getuid(\nerikh\n)}\n\n\n\n\n\ngetgid\n\n\ngetgid, given a string group name provides an integer response with the GID\nof the group. This works by reading the /etc/group file in the image.\n\n\nYields an error if it cannot find the group or from has not been called.\n\n\nExample:\n\n\nfrom \ndebian\n\nrun \ngroupadd cabal\n\nrun \ngetent group #{getgid(\ncabal\n)}", 
            "title": "Function Reference"
        }, 
        {
            "location": "/functions/#import", 
            "text": "import loads a ruby file, and then executes it as if it were a box plan. This\nis prinicipally used to modularize build instructions between multiple builds.  Note that this will load ruby files specified anywhere on the filesystem. Use\nat your own risk. You can provide the  -o import  option to omit this function\nfrom use.  Example:  File A:  from  debian   File B imports File A and builds on it:  import  file-a.rb \nrun  ls", 
            "title": "import"
        }, 
        {
            "location": "/functions/#getenv", 
            "text": "getenv retrieves a value from the building environment (passed in as string)\nand returns a string with the value. If no value exists, an empty string is\nreturned.  Example:  # If you set IMAGE=ceph/rbd:latest in your environment, that would be pulled\n# via the `from` statement.\nfrom getenv( IMAGE )", 
            "title": "getenv"
        }, 
        {
            "location": "/functions/#read", 
            "text": "read takes a filename as string, reads it from the latest image in the\nevaluation and returns its data. Yields an error if the file does not exist\nor from has not been called.  read returns a string which may then be manipulated with normal string\nmanipulations in ruby.  Example:  from  debian \n# this gets the first username in your passwd file inside the debian image\nrun  echo #{read( /etc/passwd ).split( \\n ).first.split( : )[0]}", 
            "title": "read"
        }, 
        {
            "location": "/functions/#getuid", 
            "text": "getuid, given a string username provides an integer response with the UID of\nthe user. This works by reading the /etc/passwd file in the image.  Yields an error if it cannot find the user or from has not been called.  Example:  from  debian \nrun  useradd -m -d /home/erikh -s /bin/sh erikh \nrun  id #{getuid( erikh )}", 
            "title": "getuid"
        }, 
        {
            "location": "/functions/#getgid", 
            "text": "getgid, given a string group name provides an integer response with the GID\nof the group. This works by reading the /etc/group file in the image.  Yields an error if it cannot find the group or from has not been called.  Example:  from  debian \nrun  groupadd cabal \nrun  getent group #{getgid( cabal )}", 
            "title": "getgid"
        }
    ]
}